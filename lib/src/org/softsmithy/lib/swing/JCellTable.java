package puce.swing;

import javax.swing.table.*;
import puce.swing.table.*;


public class JCellTable extends JXTable {
  
  /** Autogenerated proxy constructor. */
  public JCellTable(CellTableModel ctm) {
    super(ctm);
  }

  
  /** Returns an appropriate renderer for the cell specified by this row and
   * column. If the <code>TableColumn</code> for this column has a non-null
   * renderer, returns that.  If not, finds the class of the data in
   * this column (using <code>getColumnClass</code>)
   * and returns the default renderer for this type of data.
   * <p>
   * <b>Note:</b>
   * Throughout the table package, the internal implementations always
   * use this method to provide renderers so that this default behavior
   * can be safely overridden by a subclass.
   *
   * @param row       the row of the cell to render, where 0 is the first row
   * @param column    the column of the cell to render,
   * 			where 0 is the first column
   * @return the assigned renderer; if <code>null</code>
   * 			returns the default renderer
   * 			for this type of object
   * @see javax.swing.table.DefaultTableCellRenderer
   * @see javax.swing.table.TableColumn#setCellRenderer
   * @see #setDefaultRenderer
   *
   */
  public TableCellRenderer getCellRenderer(int row, int column) {
    TableCellRenderer renderer = getDefaultRenderer(getCellClass(row, column));
    return renderer;
  }
  
  /** Returns an appropriate editor for the cell specified by
   * <code>row</code> and <code>column</code>. If the
   * <code>TableColumn</code> for this column has a non-null editor,
   * returns that.  If not, finds the class of the data in this
   * column (using <code>getColumnClass</code>)
   * and returns the default editor for this type of data.
   * <p>
   * <b>Note:</b>
   * Throughout the table package, the internal implementations always
   * use this method to provide editors so that this default behavior
   * can be safely overridden by a subclass.
   *
   * @param row       the row of the cell to edit, where 0 is the first row
   * @param column    the column of the cell to edit,
   * 			where 0 is the first column
   * @return          the editor for this cell;
   * 			if <code>null</code> return the default editor for
   *  		this type of cell
   * @see DefaultCellEditor
   *
   */
  public TableCellEditor getCellEditor(int row, int column) {
    return getDefaultEditor(getCellClass(row, column));
  }
  
  public Class getCellClass(int row, int column){
    return getCellTableModel().getCellClass(row, column);
  }

  
  /** Sets the data model for this table to <code>newModel</code> and registers
   * with it for listener notifications from the new data model.
   *
   * @param   newModel        the new data source for this table
   * @exception IllegalArgumentException      if <code>newModel</code> is <code>null</code>
   * @see     #getModel
   * @beaninfo
   *  bound: true
   *  description: The model that is the source of the data for this view.
   *
   */
  public void setModel(TableModel cellTableModel) {
    if (! (cellTableModel instanceof CellTableModel)){
      throw new IllegalArgumentException("cellTableModel must be a CellTableModel");
    }
    super.setModel(cellTableModel);
  }
  
  public CellTableModel getCellTableModel(){
    return (CellTableModel) getModel();
  }
  
  public void setCellTableModel(CellTableModel cellTableModel){
    setModel(cellTableModel);
  }
  
}
