/*
 *                  Sun Public License Notice
 *
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 *
 * The Original Code is SoftSmithy Utility Library. The Initial Developer of the
 * Original Code is Florian Brunner (Sourceforge.net user: puce). All Rights Reserved.
 *
 * Contributor(s): .
 */

/*
 * JCustomizerPane.java
 *
 * Created on 21. August 2002, 16:20
 */

package org.softsmithy.lib.swing;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import org.softsmithy.lib.awt.event.*;
import org.softsmithy.lib.awt.layout.*;
import org.softsmithy.lib.swing.customizer.*;
import org.softsmithy.lib.swing.event.*;



/**
 *
 * @author  puce
 */
public class JCustomizerPane extends AbstractCustomizer implements MouseListener{
  
  
  /** Holds value of property showingConstraints. */
  private boolean showingConstraints = true;
  
  /** Holds value of property selectionManager. */
  private SelectionManager selectionManager = new SelectionManager();
  
  /** Holds value of property customizerBar. */
  private CustomizerBar customizerBar;
  
  
  //private final ActivationManager activationManager = new ActivationManager();
  
  /** Holds value of property active. */
  private boolean active;
  
  private boolean inited = false;
  
  /** Creates new form JCustomizerPane */
  public JCustomizerPane() {
    initComponents();
    inited = true;
    setLayout(new InfiniteTableLayout(this));
    setSize(400, 300);
    //setFocusable(true);//setRequestFocusEnabled(true);
    addMouseListener(this);
    this.setBackground(Color.WHITE);
    //    Action deleteAction = new AbstractAction("delete") {
    //      public void actionPerformed(ActionEvent e) {
    //        System.out.println(e.getSource() + " deleted!");
    //      }
    //    };
    //    getActionMap().put(deleteAction.getValue(Action.NAME),
    //    deleteAction);
    //
    //    getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke("DELETE"),
    //    deleteAction.getValue(Action.NAME));
    
  }
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents() {//GEN-BEGIN:initComponents

    setLayout(null);

  }//GEN-END:initComponents
  
  
  
  /** Getter for property showingConstraints.
   * @return Value of property showingConstraints.
   */
  public boolean isShowingConstraints() {
    return this.showingConstraints;
  }
  
  /** Setter for property showingConstraints.
   * @param showingConstraints New value of property showingConstraints.
   */
  public void setShowingConstraints(boolean showingConstraints) {
    this.showingConstraints = showingConstraints;
  }
  
  /** Calls the UI delegate's paint method, if the UI delegate
   * is non-<code>null</code>.  We pass the delegate a copy of the
   * <code>Graphics</code> object to protect the rest of the
   * paint code from irrevocable changes
   * (for example, <code>Graphics.translate</code>).
   * <p>
   * If you override this in a subclass you should not make permanent
   * changes to the passed in <code>Graphics</code>. For example, you
   * should not alter the clip <code>Rectangle</code> or modify the
   * transform. If you need to do these operations you may find it
   * easier to create a new <code>Graphics</code> from the passed in
   * <code>Graphics</code> and manipulate it. Further, if you do not
   * invoker super's implementation you must honor the opaque property,
   * that is
   * if this component is opaque, you must completely fill in the background
   * in a non-opaque color. If you do not honor the opaque property you
   * will likely see visual artifacts.
   *
   * @param g the <code>Graphics</code> object to protect
   * @see #paint
   * @see ComponentUI
   */
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (isShowingConstraints()){
      Color oldColor = g.getColor();
      g.setColor(Color.LIGHT_GRAY);
      ((TableLayout) getLayout()).drawGrid(this, g);
      g.setColor(oldColor);
    }
    /* First painting occurs at (x,y), where x is at least
      insets.left, and y is at least insets.height. */
  }
  
  /** Invoked when the mouse button has been clicked (pressed
   * and released) on a component.
   *
   */
  public void mouseClicked(MouseEvent e) {
  }
  
  /** Invoked when the mouse enters a component.
   *
   */
  public void mouseEntered(MouseEvent e) {
  }
  
  /** Invoked when the mouse exits a component.
   *
   */
  public void mouseExited(MouseEvent e) {
  }
  
  
  /** Invoked when a mouse button has been released on a component.
   *
   */
  public void mouseReleased(MouseEvent e) {
  }
  
  /** Getter for property selectionManager.
   * @return Value of property selectionManager.
   *
   */
  public SelectionManager getSelectionManager() {
    return this.selectionManager;
  }
  
  /** Invoked when a mouse button has been pressed on a component.
   *
   */
  public void mousePressed(MouseEvent e) {
    if(!hasFocus()){
      requestFocus();
      getSelectionManager().clearSelection();
    }
    if (customizerBar != null && customizerBar.hasSelection()){
      customizerBar.consumeSelection(this, e.getPoint());
    }
  }
  
  /** Getter for property customizerBar.
   * @return Value of property customizerBar.
   *
   */
  public CustomizerBar getCustomizerBar() {
    return this.customizerBar;
  }
  
  /** Setter for property customizerBar.
   * @param customizerBar New value of property customizerBar.
   *
   */
  public void setCustomizerBar(CustomizerBar customizerBar) {
    this.customizerBar = customizerBar;
  }
  
  /** Setter for property selectionManager.
   * @param selectionManager New value of property selectionManager.
   *
   */
  public void setSelectionManager(SelectionManager selectionManager) {
    this.selectionManager = selectionManager;
  }
  
  public JCustomizer[] getCustomizers() {
    return (JCustomizer[]) Arrays.asList(getComponents()).toArray(new JCustomizer[getComponents().length]);
  }
  
  /**
   * Sets the layout manager for this container.
   * @param mgr the specified layout manager
   * @see #doLayout
   * @see #getLayout
   *
   */
  public void setLayout(LayoutManager mgr) {
    if (inited){
      if (! (mgr instanceof CustomizerLayout)){
        throw new IllegalArgumentException("mgr must be an instance of CustomizerLayout!");
      }
    }
    super.setLayout(mgr);
  }
  
  /** Adds the specified component to this container at the specified
   * index. This method also notifies the layout manager to add
   * the component to this container's layout using the specified
   * constraints object via the <code>addLayoutComponent</code>
   * method.  The constraints are
   * defined by the particular layout manager being used.  For
   * example, the <code>BorderLayout</code> class defines five
   * constraints: <code>BorderLayout.NORTH</code>,
   * <code>BorderLayout.SOUTH</code>, <code>BorderLayout.EAST</code>,
   * <code>BorderLayout.WEST</code>, and <code>BorderLayout.CENTER</code>.
   *
   * <p>Note that if the component already exists
   * in this container or a child of this container,
   * it is removed from that container before
   * being added to this container.
   * <p>
   * This is the method to override if a program needs to track
   * every add request to a container as all other add methods defer
   * to this one. An overriding method should
   * usually include a call to the superclass's version of the method:
   * <p>
   * <blockquote>
   * <code>super.addImpl(comp, constraints, index)</code>
   * </blockquote>
   * <p>
   * @param     comp       the component to be added
   * @param     constraints an object expressing layout constraints
   *                 for this component
   * @param     index the position in the container's list at which to
   *                 insert the component, where <code>-1</code>
   *                 means append to the end
   * @exception IllegalArgumentException if <code>index</code> is invalid
   * @exception IllegalArgumentException if adding the container's parent
   * 			to itself
   * @exception IllegalArgumentException if adding a window to a container
   * @see       #add(Component)
   * @see       #add(Component, int)
   * @see       #add(Component, java.lang.Object)
   * @see       LayoutManager
   * @see       LayoutManager2
   * @since     JDK1.1
   *
   */
  protected void addImpl(Component comp, Object constraints, int index) {
    if (! (comp instanceof JCustomizer)){
      throw new IllegalArgumentException("comp must be an instance of JCustomizer!");
    }
    if (! (constraints instanceof CustomizerConstraints)){
      throw new IllegalArgumentException("constraints must be an instance of CustomizerConstraints!");
    }
    super.addImpl(comp, constraints, index);
  }
  
  public void addCustomizer(JCustomizer customizer, CustomizerConstraints constraints){
    add(customizer, constraints);
  }
  
  /** Getter for property active.
   * @return Value of property active.
   *
   */
  public boolean isActive() {
    return this.active;
  }
  
  /** Setter for property active.
   * @param active New value of property active.
   *
   */
  public void setActive(boolean active) {
    if (active != isActive()){
      boolean oldActive = isActive();
      this.active = active;
      firePropertyChange("active", oldActive, active);
    }
  }
  
  
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  
}
