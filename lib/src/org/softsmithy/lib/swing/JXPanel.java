/*
 *                  Sun Public License Notice
 *
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 *
 * The Original Code is SoftSmithy Utility Library. The Initial Developer of the
 * Original Code is Florian Brunner (Sourceforge.net user: puce). All Rights Reserved.
 *
 * Contributor(s): .
 */

/*
 * JXPanel.java
 *
 * Created on 25. April 2003, 18:03
 */

package org.softsmithy.lib.swing;

import java.awt.*;
import java.beans.*;
import javax.swing.*;

/**
 *
 * @author  puce
 */
public class JXPanel extends JPanel {
  
  /** Holds value of property backgroundPaint. */
  private Paint backgroundPaint;
  
  /** Creates new form JXPanel */
  public JXPanel() {
    initComponents();
  }
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents() {//GEN-BEGIN:initComponents
    
    setLayout(new java.awt.BorderLayout());
    
  }//GEN-END:initComponents
  
  /** Calls the UI delegate's paint method, if the UI delegate
   * is non-<code>null</code>.  We pass the delegate a copy of the
   * <code>Graphics</code> object to protect the rest of the
   * paint code from irrevocable changes
   * (for example, <code>Graphics.translate</code>).
   * <p>
   * If you override this in a subclass you should not make permanent
   * changes to the passed in <code>Graphics</code>. For example, you
   * should not alter the clip <code>Rectangle</code> or modify the
   * transform. If you need to do these operations you may find it
   * easier to create a new <code>Graphics</code> from the passed in
   * <code>Graphics</code> and manipulate it. Further, if you do not
   * invoker super's implementation you must honor the opaque property,
   * that is
   * if this component is opaque, you must completely fill in the background
   * in a non-opaque color. If you do not honor the opaque property you
   * will likely see visual artifacts.
   *
   * @param g the <code>Graphics</code> object to protect
   * @see #paint
   * @see ComponentUI
   *
   */
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (isOpaque() && getBackgroundPaint() != null){
      Graphics2D g2 = (Graphics2D) g;
      Paint oldPaint = g2.getPaint();
      g2.setPaint(getBackgroundPaint());
      g2.fill(SwingUtilities.calculateInnerArea(this, null));
      g2.setPaint(oldPaint);
    }
  }
  
  /** Getter for property backgroundPaint.
   * @return Value of property backgroundPaint.
   *
   */
  public Paint getBackgroundPaint() {
    return this.backgroundPaint;
  }
  
  /** Setter for property backgroundPaint.
   * @param backgroundPaint New value of property backgroundPaint.
   *
   */
  public void setBackgroundPaint(Paint backgroundPaint) {
    Paint oldBackgroundPaint = this.backgroundPaint;
    this.backgroundPaint = backgroundPaint;
    firePropertyChange("backgroundPaint", oldBackgroundPaint, backgroundPaint);
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  
}
